All the socket handling, packed into a function that hooks on to a ws
socket server.

    _ = require('lodash')
    uuid = require('node-uuid')
    fs = require('fs')
    path = require('path')
    yaml = require('js-yaml')

Track running sockets to get a sense of all sessions.

    sockets = {}
    rooms = {}

    module.exports = (wss, config) ->

Bad news straight to the console

      wss.on 'error', (error) ->
        console.error "#{error}".red

Sockety goodness, here are all the event handlers on a per socket basis.

      wss.on 'connection', (socket) ->
        socket.screens = {}

Signal -- send a message back to the connected client, this patches a method
directly on to the socket that follows our type/detail protocol that makes
WebSocket messages essentially the same as DOM events.

        socket.signal = (type, detail) ->
          message =
            type: type
            detail: detail or {}
          console.log '<-'.green, yaml.safeDump(message), '\n---'.green
          message = JSON.stringify(message)
          socket.send message, (err) ->
            if err
              console.log "#{err}".red

Update everyone in the room with the current room state. This is a list of
client identifiers that informs a connected client session who it may need
to call or disconnect.

        roomChanged = ->
          _.each rooms[socket.room], (peerSocket) ->
            try
              peerSocket.signal 'roomlist',
                _(rooms[socket.room])
                  .values()
                  .map (s) -> s.clientid
                  .value()
              peerSocket.signal 'roomscreens',
                _(rooms[socket.room])
                  .values()
                  .map (s) -> s.screens
                  .map (s) -> _.values(s)
                  .flatten()
                  .value()
            catch err
              console.log "#{err}".red


Send a hello on a connection, this tells the client to get going.

        socket.signal 'hello'

Translate messages into events allowing declarative event handling. This is
in charge of setting up the `clientid` on to socket, but not registering in
`sockets`.

        socket.on 'message', (req) ->
          try
            message = JSON.parse(req)
            return if message.ping #logging pings will drive you mad
            console.log '->'.blue, yaml.safeDump(message), '\n---'.blue
            socket.clientid = message.clientid
            socket.emit message.type, message.detail
          catch error
            console.error "#{error}".red

Client setup, captures the identifier so this client can be called if found.
This identifier is randomly generated by each client. This allows you to log on
from multiple locations, and thus call yourself at different locations. And it
means you can clear out your local storage on any client and get a different
identifier, providing for privacy.

This is a problem if two clients allocate the same identifier, so clients need
to protect users by creating a nice big random string that is hard to guess. If
this happens, which is easy enough to do by opening two tabs, a disconnect
message is sent, which should be honored by the previous client tab to close
off. This way the most recent tab ends up being the live one.

Rooms are simply a hash of sockets in the room. This lets you send messages
along to just the members of the room easily, since every socket is marked
with both a client and a room. So -- this means any given socket can only
be in one room. For sure!

        socket.on 'register', (user) ->
          sockets[socket.clientid] = socket
          delete rooms?[socket.room]?[socket.clientid]
          roomChanged()
          socket.room = user.room
          rooms[socket.room] ?= {}
          rooms[socket.room][socket.clientid] = socket

Provide configuration to the client.

          socket.signal 'configured', config
          roomChanged()

Send WebRTC negotiation along to all peers and let them process it, this will
reflect ice back to the sender, this allows self-calling for testing.

        signalRTC = (type, detail) ->
          fromSocket = sockets[detail.fromclientid]
          toSocket = sockets[detail.toclientid]
          if fromSocket
            fromSocket.signal type, detail
          if toSocket
            toSocket.signal type, detail
        socket.on 'ice', (detail) -> signalRTC('ice', detail)
        socket.on 'offer', (detail) -> signalRTC('offer', detail)
        socket.on 'answer', (detail) -> signalRTC('answer', detail)

Start off a call, the job here is to figure if the called client exists, then
send along messages to start peer to peer call setup on the inbound (caller)
and outbound (callee) side the client ends up doing the bulk of the work, this
is just matchmaking.

This has a special case for debugging if you call 'fail' which sets up an
outbound call to nobody to test failing RTC negotiation.

Calls are made 'from' a caller 'to' a callee. The caller is will set up
an 'outboundcall', the callee will set up an 'inboundcall'. Part of this setup
is double checking if a call already exists.

        socket.on 'call', (detail) ->

          if detail.to is 'fail'
            outboundcall =
              outbound: true
              toclientid: 'fail'
              fromclientid: 'fail'
            socket.signal 'outboundcall', outboundcall

          tosocket = sockets[detail.to]
          if tosocket
            console.log "connecting #{socket.clientid} to #{tosocket.clientid}".blue
            outboundcall =
              id: uuid.v1()
              outbound: true
              fromclientid: socket.clientid
              toclientid: tosocket.clientid
            inboundcall =
              id: uuid.v1()
              inbound: true
              fromclientid: socket.clientid
              toclientid: tosocket.clientid
            socket.signal 'outboundcall', outboundcall
            tosocket.signal 'inboundcall', inboundcall

        socket.on 'ping', ->
          hashes = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '..', 'build', 'hashmap.json'), 'utf8'))
          hashes.nolog = true
          socket.signal 'pong', hashes

Handle incoming shared screens. These get registered into the room, but are removed
when the socket goes away, so they aren't as sticky as calls, so we put them
on the client.

        socket.on 'screen', (screen) ->
          socket.screens[screen.id] = screen
          roomChanged()

Close removes the socket from tracking, but make sure to only remove yourself.

        socket.on 'close', ->
          try
            if sockets[socket.clientid] is socket
              delete sockets[socket.clientid]
              delete rooms[socket.room][socket.clientid]
              roomChanged()
          catch error
            console.error "#{error}".red
